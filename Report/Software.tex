%!TEX root = Main.tex
\documentclass[Main]{subfiles}

\begin{document}

\section{Software} % (fold)
\label{sec:software}

	In this project, software was a vital part. 
	While the course theory had presented ways of doing 
	In this chapter, the coding environment, structure and behaviour of the codebase will be covered.
	
	\subsection{Environment} % (fold)
	\label{sub:software_environment}

		The software for this project was written in C++ using the Xilinx Software Development Kit.
		C++ was chosen because it is a object oriented library, which gave some clear advantages when working in a three person team.
		Furthermore, C++ has native support for an resizable array datatype known as a vector, which greatly reduced the complexity of manipulating array.
		The software was written for the C++11 standard, since the standard gave some advantages in initialisation of vectors.
		GitHub was used for version control	to manage and backup code.
		
\fxnote{Write Something about Map}
		
	\subsection{Design} % (fold)
	\label{sub:software_design}

	\subsubsection{Structure} % (fold)
	\label{subsub:software_structure}
		A object-oriented approach was taken to the design, in order to modulize the different parts of the software. 
		
		This gave clear advantages when working multiple people on the same codebase, as the development of the different classes could be spread out between multiple people.
		
		The structure of the software is depicted in \autoref{fig:classdiagram} as a UML class diagram.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=\linewidth]{ClassDiagram}
			\caption{Class Diagram}
			\label{fig:classdiagram}
		\end{figure}
		
		The main components of the program is the LIDAR, PathMaker, RobotFrame and ParticleFilter classes. 
		Each class has a distinct purpose, which maps directly to one of the four  actions in the main loop of \autoref{fig:systemact}.
		The mapping can be see in \autoref{table:action_class_map}
		 
		\begin{table}[H]
			\centering
			\begin{tabular}{|c|c|}
			\hline
				Action & Class \\ 
			\hline
				A2: Sense Data & LIDAR  \\ 
			\hline
				A3: Estimate Robot Position & ParticleFilter  \\ 
			\hline
				A4: Calculate Path & PathMaker  \\ 
			\hline
				A5: Move & RobotFrame  \\ 
			\hline
			\end{tabular}
			\caption{Grid map for demonstration}
			\label{table:action_class_map} 
		\end{table} \noindent
		
	\subsubsection{Behaviour} % (fold)
	\label{subsub:software_behaviour}

		The dataflow between the different classes is covered in the Internal Block Diagram in \autoref{fig:softwareibd}
		
		\begin{figure}[H]
			\centering
			\includegraphics{SoftwareIBD}
			\caption{Software Internal Block Diagram}
			\label{fig:softwareibd}
		\end{figure}

		The raw sensor data from the Sensing block in \autoref{fig:systemibd} is sent to the LIDAR class, which  converts the raw sensor data to 360 distance values.
		The sensor data is sent to the ParticleFilter class, which update its current particle weights. 
		These weights are used to resample the particles using the low variance sampling technique presented in the course material.
		The robots position is then estimated by taking the position of the particle with the biggest weight.
		This position is used in the PathMaker, which performs AStar to find the best path to the goal. The next move from this path is then sent to both the RobotFrame class and the ParticleFilter, to move both the robot and the Particles along the expected path.
		The RobotFrame class uses the MotorControl class to send a control signal to the Motion block from \autoref{fig:systemibd}, which converts the control to a PMW signal that controls the motors of the robot.
		
	
	\subsection{Implementation} % (fold)
	\label{sub:software_implementation}
	
	The code was implemented according to the design. 
	The code can be found in \fxnote{CodeBae Reference}.
	The main function of the program has been included to reflect how the design was implemented.
	
	\begin{lstlisting}[caption=Main Function of Progam, style=Code-C++, label=lst:main_code]
	
	int main(void) {
		Position goal;
		goal.x = GOAL_X;
		goal.y = GOAL_Y;
		goal.orientation = GOAL_ORIENTATION;
	
		PathMaker* pathMaker = new PathMaker();
		pathMaker->setGoal(goal);
		pathMaker->loadMap();
	
		RobotFrame* robotFrame = new RobotFrame();
		robotFrame->pos.x = 4;
		robotFrame->pos.y = 4;
	
		ParticleFilter* particleFilter = new ParticleFilter(pathMaker->map);
		LIDAR* lidar = new LIDAR();
		MoveBlock nextMove;
	
		while (1) {
			if (pathMaker->checkGoal(robotFrame->pos) != true) {
				
				lidar->senseData();
				
				particleFilter->updateWeigths(lidar->dataArray, pathMaker->map);
				particleFilter->resample(pathMaker->map);
				particleFilter->getNewPosition(robotFrame->pos);
				
				pathMaker->performAStar(robotFrame->pos);
				pathMaker->getNextMove(nextMove);
				
				robotFrame->move(nextMove);
				particleFilter->moveParticles(nextMove);
			}
			else
			{
				std::cout << "Found Goal" << std::endl;
				return 0;
			}
	
		}
		return 0;
	}
	
	\end{lstlisting}

	\subsubsection{ParticleFilter} % (fold)
	\label{subsub:software_particlefilter}
	Ingen landmarks, derfor ikke kalman
	Kan trække raw data ind i partikle
	Nemmere at implementere partiklefilter
	10.000 partikler
	Random på 5% af partikler
	exp(Log - likehood) til at bestemme vægten
	Der normaliseres med N
	Så man får average likelyhood
	Den med størst vægt bliver så det most probable position
	Partilefilter - der laves et range map, med [32][32][180] sæt af distancer.
	
	\subsubsection{PathMaker} % (fold)
	\label{subsub:software_pathmaker}
	Gridded er en 32x32 med 10 cm grids
	Cost bliver movement cost + heuristik + penalty map
	Penality map fordi robotten er større end griddet.
	Så for at undgå at robotten køre ind i vægene
	A* bruges da det vil kunne undgå obstacels
	
	\subsubsection{MotrolControl} % (fold)
	\label{subsub:software_motorcontrol}
	Hvordan en global moveblock laves om til en movement control
	
% section software (end)
\end{document}