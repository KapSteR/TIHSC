#include "Particle.h"
#include "Utility.h"

Particle::Particle(){
    
}

void Particle::move(MoveBlock& MB){
//    pos.orientation = fmod((pos.orientation + MB.angle), 2*M_PI);
//
//    float directionX = cos(pos.orientation) * MB.distance;
//    pos.x += directionX;
//    float directionY = sin(pos.orientation) * MB.distance;
//    pos.y -= directionY;

	cont_orientation = (cont_orientation + MB.angle)%360;


	float directionX = cos((float)(cont_orientation)/360*M_TWOPI) * MB.distance*GRID_SIZE; // TODO: Make sin/con table ?
	cont_x += directionX;
	float directionY = sin((float)(cont_orientation)/360*M_TWOPI) * MB.distance*GRID_SIZE;
	cont_y -= directionY;

	quantizePosition();
    
}

void Particle::quantizePosition() {
	pos.x = (int)cont_x/GRID_SIZE;
	pos.y = (int)cont_y/GRID_SIZE;

	if ((cont_orientation >= 45) && (cont_orientation < 135)){

		pos.orientation = 90;

	} else if ((cont_orientation >= 135) && (cont_orientation < 225)) {

		pos.orientation = 180;

	} else if ((cont_orientation >= 225) && (cont_orientation < 270)) {

		pos.orientation = 270;

	} else {

		pos.orientation = 0;

	}
}

float Particle::weightCalculation(int* dataArray){
    
    float prob = 0.0;
    int distDif;
    int angleIndex;
    int measurement[NUM_ANGLES]; //[8];

    for (int i = 0; i < NUM_ANGLES ; i++ ) {

    	measurement[i] = dataArray[2*i];
    }

//    measurement[0] = dataArray[0];
//    measurement[1] = dataArray[44];
//    measurement[2] = dataArray[90];
//    measurement[3] = dataArray[136];
//    measurement[4] = dataArray[180];
//    measurement[5] = dataArray[224];
//    measurement[6] = dataArray[270];
//    measurement[7] = dataArray[316];


    
    
    int n = 0;
    
    for(int i = 0; i < NUM_ANGLES; i++){
        if (measurement[i] != -1){
//            angleIndex = (int)(float(pos.orientation / M_PI_4) + i) % 8;
        	angleIndex = pos.orientation/2;
            
            distDif = RangeArray[pos.y][pos.x][angleIndex]-measurement[i];
            prob += (normalizer - 0.5*(pow(distDif,2))/(noiseSqr));
            n++;
        }
        std::cout << "Angle: " << i << std::endl;
    }
    
    if(n == 0)
        return 0;
    else
        return exp(prob/(float)n);
}
