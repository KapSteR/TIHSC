/*
 * Empty C++ Application
 */

#include <math.h>
#include "xparameters.h"
#include "xmotorctrl.h"
#include "xscutimer.h"

#define TIMER_DEVICE_ID		XPAR_XSCUTIMER_0_DEVICE_ID

#define TURNRATE50 M_PI // SET THIS !!! rad/s
#define MOVERATE50 330 // SET THIS !!! mm/s
#define ONE_SECOND 325000000


// Function Declarations
void move(float poseAngle, int distance, float heading);
int ScuTimerWait(u16 DeviceId, u32 timeOut);
void initMotor(XMotorctrl* motor);

XMotorctrl motor; // Motor controller instance
XScuTimer Timer;		/* Cortex A9 SCU Private Timer Instance */

int main() {

	xil_printf("Start of program. Robot assumed to be heading east\r\n");

	initMotor(&motor);

	xil_printf("Move 1 meter north\r\n");
	move(0,1000,M_PI_2);
	xil_printf("Wait one second\r\n");
	ScuTimerWait(TIMER_DEVICE_ID,ONE_SECOND);
	xil_printf("Move 0.5 meters south\r\n");
	move(90,500,(3*M_PI_2));

;	xil_printf("End of program\r\n");

	return 0;
}

void move(float poseAngle, int distance, float heading) {

	float h_p;
	float p_h;
	float turnAngle;

	int turnSpeedRight;
	int turnSpeedLeft;
	int turnTime;
	int moveTime;

	h_p = fmod(heading - poseAngle, M_TWOPI);
	p_h = fmod(poseAngle - heading, M_TWOPI);

	if (h_p >= p_h) {  // Left turn

		turnSpeedLeft = 0;
		turnSpeedRight = 512; // 50%
		turnAngle = p_h;

	} else { // Right turn

		turnSpeedLeft = 512; // 50%
		turnSpeedRight = 0;
		turnAngle = h_p;
	}

	// Calc turn time
	turnTime = turnAngle * TURNRATE50 * ONE_SECOND;
	// Start turn
	XMotorctrl_SetPwmr(&motor, turnSpeedRight);
	XMotorctrl_SetPwml(&motor, turnSpeedLeft);
	XMotorctrl_SetDirection(&motor, 1);
	// Set Timer	// Wait

	ScuTimerWait(TIMER_DEVICE_ID,turnTime);

	// Stop turn
	XMotorctrl_SetPwmr(&motor, 0);
	XMotorctrl_SetPwml(&motor, 0);

	// Wait 0.5 seconds
	ScuTimerWait(TIMER_DEVICE_ID,112500000);

	// Move
	// Calc move time
	moveTime = distance * MOVERATE50 * ONE_SECOND;
	// Start move
	XMotorctrl_SetPwmr(&motor, 512);
	XMotorctrl_SetPwml(&motor, 512);
	XMotorctrl_SetDirection(&motor, 1);
	// Set timer	// wait

	ScuTimerWait(TIMER_DEVICE_ID,moveTime);

	// Stop move
	XMotorctrl_SetPwmr(&motor, 0);
	XMotorctrl_SetPwml(&motor, 0);

	// Return
	return;

}

void initMotor(XMotorctrl* motor){

	motor->IsReady = XIL_COMPONENT_IS_READY;
	motor->Slv0_BaseAddress = XPAR_MOTORCTRL_0_S_AXI_SLV0_BASEADDR;

	XMotorctrl_SetPwmr(motor, 0);
	XMotorctrl_SetPwml(motor, 0);
	XMotorctrl_SetDirection(motor, 0);
}

int ScuTimerWait(u16 DeviceId, u32 timeOut) // Timeout in timer ticks
{
	int Status;
	XScuTimer_Config *ConfigPtr;
	XScuTimer *TimerInstancePtr = &Timer;

	/*
	 * Initialize the Scu Private Timer so that it is ready to use.
	 */
	ConfigPtr = XScuTimer_LookupConfig(DeviceId);

	/*
	 * This is where the virtual address would be used, this example
	 * uses physical address.
	 */
	Status = XScuTimer_CfgInitialize(TimerInstancePtr, ConfigPtr,
				 ConfigPtr->BaseAddr);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Load the timer decrement register.
	 */
	XScuTimer_LoadTimer(TimerInstancePtr, timeOut);

	/*
	 * Start the Scu Private Timer device.
	 */
	XScuTimer_Start(TimerInstancePtr);

	while (XScuTimer_GetCounterValue(TimerInstancePtr) != 0) {

		// Wait for timer to expire

	}
	// Stop timer after use
	XScuTimer_Stop(TimerInstancePtr);

	return XST_SUCCESS;
}

