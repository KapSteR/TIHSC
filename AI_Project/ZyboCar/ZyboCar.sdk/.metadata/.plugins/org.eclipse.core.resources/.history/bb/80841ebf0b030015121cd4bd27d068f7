/*
 * Empty C++ Application
 */

#include <math.h>
#include "xparameters.h"
#include "xmotorctrl.h"
#include "xscutimer.h"

#define TIMER_DEVICE_ID		XPAR_XSCUTIMER_0_DEVICE_ID
#define TIMER_LOAD_VALUE	0xFF

#define TURNRATE50 M_PI // SET THIS !!! rad/s
#define MOVERATE50 330 // SET THIS !!! mm/s
#define ONE_SECOND 325000000

void move(float poseAngle, int distance, float heading);

void initMotor(XMotorctrl* motor);

XMotorctrl motor; // Motor controller instance
XScuTimer Timer;		/* Cortex A9 SCU Private Timer Instance */

int main() {

	int Status;

	initMotor(&motor);


	return 0;
}

void move(float poseAngle, int distance, float heading) {

	float h_p;
	float p_h;
	float turnAngle;

	int turnSpeedRight;
	int turnSpeedLeft;
	int turnTime;
	int moveTime;

	h_p = fmod(heading - poseAngle, M_TWOPI);
	p_h = fmod(poseAngle - heading, M_TWOPI);

	if (h_p >= p_h) {  // Left turn

		turnSpeedLeft = 0;
		turnSpeedRight = 512; // 50%
		turnAngle = p_h;

	} else { // Right turn

		turnSpeedLeft = 512; // 50%
		turnSpeedRight = 0;
		turnAngle = h_p;
	}

	// Calc turn time
	turnTime = turnAngle * TURNRATE50 * ONE_SECOND;
	// Start turn
	XMotorctrl_SetPwmr(&motor, turnSpeedRight);
	XMotorctrl_SetPwml(&motor, turnSpeedLeft);
	XMotorctrl_SetDirection(&motor, 1);
	// Set Timer
	// Wait
	// Stop turn
	XMotorctrl_SetPwmr(&motor, 0);
	XMotorctrl_SetPwml(&motor, 0);

	// Move
	// Calc move time
	moveTime = distance * MOVERATE50 * ONE_SECOND;
	// Start move
	XMotorctrl_SetPwmr(&motor, 512);
	XMotorctrl_SetPwml(&motor, 512);
	XMotorctrl_SetDirection(&motor, 1);
	// Set timer
	// wait
	// Stop move
	XMotorctrl_SetPwmr(&motor, 0);
	XMotorctrl_SetPwml(&motor, 0);

	// Return
	return;

}

void initMotor(XMotorctrl* motor){

	motor->IsReady = XIL_COMPONENT_IS_READY;
	motor->Slv0_BaseAddress = XPAR_MOTORCTRL_0_S_AXI_SLV0_BASEADDR;

	XMotorctrl_SetPwmr(motor, 0);
	XMotorctrl_SetPwml(motor, 0);
	XMotorctrl_SetDirection(motor, 0);
}

int ScuTimerWait(u16 DeviceId, int timeOut)
{
	int Status;
	volatile u32 CntValue1 = 0;
	volatile u32 CntValue2 = 0;
	XScuTimer_Config *ConfigPtr;
	XScuTimer *TimerInstancePtr = &Timer;

	/*
	 * Initialize the Scu Private Timer so that it is ready to use.
	 */
	ConfigPtr = XScuTimer_LookupConfig(DeviceId);

	/*
	 * This is where the virtual address would be used, this example
	 * uses physical address.
	 */
	Status = XScuTimer_CfgInitialize(TimerInstancePtr, ConfigPtr,
				 ConfigPtr->BaseAddr);
	if (Status != XST_SUCCESS) {
		return XST_FAILURE;
	}

	/*
	 * Load the timer counter register.
	 */
	XScuTimer_LoadTimer(TimerInstancePtr, TIMER_LOAD_VALUE);

	/*
	 * Get a snapshot of the timer counter value before it's started
	 * to compare against later.
	 */
	CntValue1 = XScuTimer_GetCounterValue(TimerInstancePtr);

	/*
	 * Start the Scu Private Timer device.
	 */
	XScuTimer_Start(TimerInstancePtr);

	/*
	 * Read the value of the timer counter and wait for it to change,
	 * since it's decrementing it should change, if the hardware is not
	 * working for some reason, this loop could be infinite such that the
	 * function does not return.
	 */
	while (1) {
		CntValue2 = XScuTimer_GetCounterValue(TimerInstancePtr);
		if (CntValue1 != CntValue2) {
			break;
		}
	}
	return XST_SUCCESS;
}

